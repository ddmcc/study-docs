---
title: 消息模型
---

### 主题和队列有什么区别？

#### 队列

就是按照“队列”的数据结构来设计的。生产者（Producer）发消息就是入队操作，消费者（Consumer）收消息就是出队也就是删除操作。这里面隐含着的一个要求是，在消息入队出队过程中，需要保证这些消息严格有序，按照什么顺序写进队列，必须按照同样的顺序从队列中读出来

![markdown](https://ddmcc-1255635056.file.myqcloud.com/fc61be61-173f-4c18-8542-19ef3b055a70.png)



1. 如果有多个生产者往同一个队列里面发送消息，这个队列中可以消费到的消息，就是这些生产者生产的所有消息的合集。消息的顺序就是这些生产者发送消息的自然顺序。如果有多个消费者接收同一个队列的消息，这些消费者之间实际上是竞争的关系，每个消费者只能收到队列中的一部分消息，也就是说任何一条消息只能被其中的一个消费者收到
2. 如果需要将一份消息数据分发给多个消费者，要求每个消费者都能收到全量的消息，例如，对于一份订单数据，风控系统、分析系统、支付系统等都需要接收消息。这个时候，单个队列就满足不了需求，一个可行的解决方式是，为每个消费者创建一个单独的队列，让生产者发送多份。显然这是个比较蠢的做法
   1. 同样的一份消息数据被复制到多个队列中会浪费资源
   2. 更重要的是，生产者必须知道有多少个消费者。为每个消费者单独发送一份消息，这实际上违背了消息队列“解耦”这个设计初衷



#### 主题

为了解决上述问题，演化出了另外一种消息模型：**发布 - 订阅模型（Publish-Subscribe Pattern）**。消息的发送方称为发布者（`Publisher`），消息的接收方称为订阅者（`Subscriber`），服务端存放消息的容器称为主题（`Topic`）。发布者将消息发送到主题中，订阅者在接收消息之前需要先订阅主题。“订阅”在这里既是一个动作，同时还可以认为是主题在消费时的一个逻辑副本，每份订阅中，订阅者都可以接收到主题的所有消息



#### 两者的区别

生产者就是发布者，消费者就是订阅者，队列就是主题，并没有本质的区别。**它们最大的区别其实就是，一份消息数据能不能被消费多次的问题。** 实际上，在这种`发布 - 订阅模型`中，如果只有一个订阅者，那它和队列模型就基本是一样的了。也就是说，`发布 - 订阅模型`在功能层面上是可以兼容`队列模型`的



### RabbitMQ消息模型

`RabbitMQ` 是坚持使用队列模型的产品之一。在 `RabbitMQ` 中，有一个 `Exchange` 模块，位于生产者和队列之间，生产者并不关心将消息发送给哪个队列，而是将消息发送给 `Exchange`，由 `Exchange` 上配置的策略来决定将消息投递到哪些队列中

![markdown](https://ddmcc-1255635056.file.myqcloud.com/7d8091f7-c3de-4d84-8eba-9cdb910f4b60.png)

同一份消息如果需要被多个消费者来消费，需要配置 `Exchange` 将消息发送到多个队列，每个队列中都存放一份完整的消息数据，变相地实现 **发布 - 订阅模型** 



### RocketMQ消息模型

`RocketMQ` 使用的消息模型是标准的 **发布 - 订阅模型**

#### 请求 - 确认机制

- **生产端**

生产者先将消息发送给服务端，也就是 `Broker`，服务端在收到消息并将消息写入主题或者队列中后，会给生产者发送确认的响应。如果生产者没有收到服务端的确认或者收到失败的响应，则会重新发送消息



- **消费端**

消费者在收到消息并完成自己的消费业务逻辑（比如，将数据保存到数据库中）后，也会给服务端发送消费成功的确认，服务端只有收到消费确认后，才认为一条消息被成功消费，否则它会给消费者重新发送这条消息，直到收到对应的消费成功确认



#### 模型

这个确认机制很好地保证了消息传递过程中的可靠性，但是，**为了确保消息的有序性，在某一条消息被成功消费之前，下一条消息是不能被消费的，否则就会出现消息空洞，违背了有序性这个原则**

也就是说，每个主题在任意时刻，至多只能有一个消费者实例在进行消费，那就没法通过水平扩展消费者的数量来提升消费端总体的消费性能。为了解决这个问题，`RocketMQ` 在主题下面增加了队列的概念：**每个主题包含多个队列，通过多个队列来实现多实例并行生产和消费。需要注意的是，RocketMQ 只在队列上保证消息的有序性，主题层面是无法保证消息的严格顺序的**

`RocketMQ` 中，订阅者的概念是通过消费组（Consumer Group）来体现的。**每个消费组都消费主题中一份完整的消息，不同消费组之间消费进度彼此不受影响，也就是说，一条消息被 Consumer Group1 消费过，也会再给 Consumer Group2 消费。消费组中包含多个消费者，同一个组内的消费者是竞争消费的关系，每个消费者负责消费组内的一部分消息。如果一条消息被消费者 Consumer1 消费了，那同组的其他消费者就不会再收到这条消息**

在 Topic 的消费过程中，由于消息需要被不同的组进行多次消费，所以消费完的消息并不会立即被删除，这就需要 RocketMQ 为每个消费组在每个队列上维护一个消费位置（Consumer Offset），这个位置之前的消息都被消费过，之后的消息都没有被消费过，每成功消费一条消息，消费位置就加一



### Kafka消息模型

`Kafka` 的消息模型和 `RocketMQ` 是完全一样的，我刚刚讲的所有 `RocketMQ` 中对应的概念，和生产消费过程中的确认机制，都完全适用于 `Kafka`。唯一的区别是，在 `Kafka` 中，队列这个概念的名称不一样，`Kafka` 中对应的名称是“分区（Partition）”，含义和功能是没有任何区别的