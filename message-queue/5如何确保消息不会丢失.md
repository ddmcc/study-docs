---
title: 如何确保消息不会丢失
---

## 检测消息是否丢失

#### 分布式链路追踪

可以使用此类系统来追踪每一条消息



#### 利用消息队列的有序性来验证

在 `生产者` 端给每个发出的消息加上一个连续递增的序号，在 `消费者` 端来检查这个序号的连续性

大多数消息队列都支持 `拦截器机制`，可以 **在生产者的拦截器中注入消息序号** ， **在消费者的拦截器中检测序号的连续性** ，这样的好处是检测代码不会侵入到业务代码中，系统稳定后也方便关闭或删除

#### 分布式系统中需要注意的问题

- 像 `Kafka` 和 `RocketMQ` 这样的消息队列，它不能保证在 `Topic` 上的严格顺序的，只能保证分区/队列上的消息是有序的，所以我们在发消息的时候必须要指定分区/队列，并且，在每个分区/队列单独检测消息序号的连续性
- 如果系统中生产者是多实例，由于并不好协调多个 `Producer` 之间的发送顺序，所以需要每个 `Producer` 分别生成各自的序号，在 `Consumer` 端按照每个 `Producer` 分别来检测序号的连续性
- `Consumer` 实例的数量最好和分区/队列数量一致，做到 `Consumer` 和分区/队列一一对应，这样会比较方便地在 `Consumer` 内检测消息序号的连续性



## 如何确保消息可靠传递

消息传递主要分为三个阶段：`生产阶段`，`存储阶段`，`消费阶段`

![](https://ddmcc-1255635056.cos.ap-guangzhou.myqcloud.com/WeChata090d8759ea5ceae2e557ed55b98078a.png)



- **生产阶段：** 消息从 `Producer` 创建出来，经过网络传输到 `Broker` 端
- **存储阶段：** 消息在 `Broker` 存储，如果是集群，消息会在这个阶段被复制到其他的副本上
- **消费阶段：** 在这个阶段，**`Consumer` 从 `Broker` 上拉取消息，经过网络传输到 `Consumer` 上**



### 生产阶段

在生产阶段，消息队列通过 **请求确认机制** ，来保证消息的可靠传递：当调用发消息方法时，消息队列客户端会将消息发送到 `Broker` ，`Broker` 收到消息后，会给客户端返回一个确认的响应，表明消息已经收到了。客户端收到响应后，完成一次正常的消息发送

只要 `Producer` 收到了 `Broker` 的确认响应，就可以保证消息在生产阶段不会丢失。有些消息队列在长时间没收到发送确认响应后，会自动重试，如果重试再失败，就会以返回值或者异常的方式告知用户



**在编写发送消息代码时，正确处理返回值或者捕获异常，就可以保证这个阶段的消息不会丢失**



### 存储阶段

在存储阶段正常情况下，只要 `Broker` 在正常运行，就不会出现丢失消息的问题，但是如果 `Broker` 出现了故障，比如进程死掉了或者服务器宕机了，还是可能会丢失消息的

**如果对消息的可靠性要求非常高，一般可以通过配置 `Broker` 参数来避免因为宕机丢消息** 

#### **单个节点Broker**

 对于单个节点的 `Broker` ，需要配置刷盘策略，将消息写入磁盘后再给 `Producer` 返回确认响应，这样即使宕机，由于消息已经写入磁盘，就不会丢失消息，恢复后还可以继续消费

>在 `RocketMQ` 中，将刷盘方式 flushDiskType 配置成 SYNC_FLUSH 同步刷盘

#### **多节点集群Broker**

如果是由多个节点组成的集群，可以将 `Broker` 集群配置成：至少将消息发送到2个以上的节点，再给客户端恢复确认响应。这样即使某个 `Broker` 宕机时，其它的 `Broker` 可以替代宕机的，也不会发生消息丢失



### 消费阶段

消费阶段采用和生产阶段类似的确认机制来保证消息的可靠传递，**客户端从 `Broker` 拉取消息后，执行业务逻辑，成功后才给 `Broker` 发送消费确认响应** ，如果没有收到响应下次拉消息的时候还会返回同一条消息，确保消息不会在网络传输过程中丢失，也不会因为客户端在执行消费逻辑中出错导致丢失

**在编写消费代码时，不要在收到消息后就立即发送消费确认，而是应该在执行完所有消费业务逻辑之后，再发送消费确认** 




## 总结

- 在生产阶段，你需要捕获消息发送的错误，并重发消息
- 在存储阶段，你可以通过配置刷盘和复制相关的参数，让消息写入到多个副本的磁盘上，来确保消息不会因为某个 Broker 宕机或者磁盘损坏而丢失
- 在消费阶段，你需要在处理完全部消费业务逻辑之后，再发送消费确认