---
title: 事务消息
---

## 事务消息解决的事情

在很多业务场景下，需要发送消息给其它系统或模块去更新数据， **事务消息中的 `事务` ，主要解决的是消息生产者本地事务和消息发送的数据一致性问题**

举个例子：我们一般在购物时，先把商品加到购物车中，然后几件商品一起下单，支付。在订单系统创建订单后，需要购物车系统将已下单的商品从购物车中删除。因为从购物车删除已下单商品这个步骤，并不是用户下单支付这个主要流程的必须步骤，删除购物车的结果也不应该影响下单的结果，所以使用消息队列来异步清理购物车是更加合理的设计


![markdown](https://ddmcc-1255635056.file.myqcloud.com/fc3a1194-9fcb-4d50-8d21-6b1b893052c0.png)

对于订单系统来说，订单创建的过程中包含两个步骤：

1. 创建订单
2. 发消息给消息队列，消息内容就是刚刚创建的订单信息

上面两个步骤任何一步都有可能失败，如果不做任何处理，那就有可能出现订单数据与购物车数据不一致的情况，比如说：

1. 创建了订单，没有清理购物车
2. 订单没创建成功，购物车里面的商品却被清掉了



也就是说：**创建订单** 和 **发送消息** 这两个步骤要么都操作成功，要么都操作失败，不允许一个成功而另一个失败的情况出现。**这也就是事务消息解决的事情：保证生产者本地事务和发送消息的数据一致性**


## 消息队列是如何实现事务的？

事务消息需要消息队列提供相应的功能才能实现，Kafka 和 RocketMQ 都提供了事务相关功能

### 半消息

暂时不能被 `Consumer`消费的消息。`Producer`已经把消息发送到 `Broker`端，但是此时消息并不能被消费，处于这种状态下的消息称为半消息。事实上，该状态下的消息会被放在一个叫做 `RMQ_SYS_TRANS_HALF_TOPIC`的主题下

当 `Producer`端对它二次确认后，也就是 `Commit`之后，`Consumer`端才可以消费到；那么如果是`Rollback`，该消息则会被删除，永远不会被消费到



![markdown](https://ddmcc-1255635056.file.myqcloud.com/6c45048a-3a3b-412f-a5f3-9dd89cda37ed.png)

首先，订单服务给消息服务器发送一个 `半消息`，如果 `半消息` 发送成功，订单服务执行创建订单操作，并提交本地事务，根据本地事务结果来决定提交或回滚半消息。如果订单创建成功，那就提交半消息，购物车服务就可以消费到这条消息，如果回滚，就删除该消息，购物车服务就不会收到这条信息。这样就实现了本地事务和发送消息的一致性



但上面还有一个问题没有解决，如果在第 **4** 步提交消息时失败了怎么办？对于这个问题，`Kafka` 和 `RocketMQ` 给出了 2 种不同的解决方案

- `Kafka` 的解决方案比较简单粗暴，直接抛出异常，让用户自行处理。我们可以在业务代码中反复重试提交，直到提交成功，或者删除之前创建的订单进行补偿
- RocketMQ 则给出了另外一种解决方案：**事务反查机制**



## RocketMQ 中的分布式事务实现

### 事务反查机制

如果生产者也就是订单服务，在提交或回滚事务消息时发生网络异常，导致消息队列没有收到请求，那么消息队列会定期反查这个消息对应的本地事务状态，然后根据反查结果决定提交或者回滚这个消息

所以订单服务需要实现一个反查本地事务状态的接口，告知消息队列本地事务是成功还是失败，`RocketMQ` 会自动根据反查的结果提交或者回滚事务消息，消息队列会以 **1** 分钟的间隔时间不断回查，直至达到事务回查最大检测数（默认 **15**），如果超过这个数字还未查询到事务状态，则回滚此消息（事务回查的频率和最大次数都可以配置）


使用 `RocketMQ` 事务消息功能实现分布式事务的流程如下图

![markdown](https://ddmcc-1255635056.file.myqcloud.com/0e802bc0-f315-4ab9-b380-854ed5baf7c0.png)


### RocketMQ 事务消息流程

发送事务消息需要实现两个方法 `executeLocalTransaction` 和 `checkLocalTransaction` ，一个是执行本地事务，另一个是本地事务回查

当调用发送消息方法时，会根据事务消息的发送结果决定是否执行本地事务方法， **如果发送成功则同步调用本地事务方法 `executeLocalTransaction` **，本地事务方法返回 **COMMIT** 或 **ROLLBACK** 那么不会执行事务反查，如果**本地事务执行状态返回 UNKNOW 或 执行异常** （本地事务状态默认为UNKNOW，且方法异常会被catch，即执行异常状态为UNKNOW，会执行反查），则定时调用 `checkLocalTransaction` 进行事务反查


### 步骤异常情况分析

- 调用 **步骤1** 发送事务消息，如果 **事务消息发送失败**，导致报错，则将异常返回，此时不会继续执行下面步骤
- 如果事务消息发送成功，但在 **执行本地事务时发生异常** ，那么本地事务数据不会被保存，此时 `Broker` 会收到未知状态，  当 `Broker` 定时回查事务状态，此时查不到本地数据，事务消息回滚
- 如果执行完本地事务，但 **未能及时的返回本地事务状态或者返回了未知状态** 。那么，会由`Broker`定时回查事务状态，然后根据事务日志表，就可以判断订单是否已完成，并写入到数据库。

基于这些，我们可以说，已经保证了本地事务和发送消息的一致性



[RocketMQ事务消息代码](https://github.com/ddmcc/rocketmq-demo/tree/main/transaction-message)



