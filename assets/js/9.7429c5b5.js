(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{750:function(_,v,t){"use strict";t.r(v);var e=t(109),o=Object(e.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h2",{attrs:{id:"事务消息解决的事情"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#事务消息解决的事情"}},[_._v("#")]),_._v(" 事务消息解决的事情")]),_._v(" "),t("p",[_._v("在很多业务场景下，需要发送消息给其它系统或模块去更新数据， "),t("strong",[_._v("事务消息中的 "),t("code",[_._v("事务")]),_._v(" ，主要解决的是消息生产者本地事务和消息发送的数据一致性问题")])]),_._v(" "),t("p",[_._v("举个例子：我们一般在购物时，先把商品加到购物车中，然后几件商品一起下单，支付。在订单系统创建订单后，需要购物车系统将已下单的商品从购物车中删除。因为从购物车删除已下单商品这个步骤，并不是用户下单支付这个主要流程的必须步骤，删除购物车的结果也不应该影响下单的结果，所以使用消息队列来异步清理购物车是更加合理的设计")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://ddmcc-1255635056.file.myqcloud.com/fc3a1194-9fcb-4d50-8d21-6b1b893052c0.png",alt:"markdown"}})]),_._v(" "),t("p",[_._v("对于订单系统来说，订单创建的过程中包含两个步骤：")]),_._v(" "),t("ol",[t("li",[_._v("创建订单")]),_._v(" "),t("li",[_._v("发消息给消息队列，消息内容就是刚刚创建的订单信息")])]),_._v(" "),t("p",[_._v("上面两个步骤任何一步都有可能失败，如果不做任何处理，那就有可能出现订单数据与购物车数据不一致的情况，比如说：")]),_._v(" "),t("ol",[t("li",[_._v("创建了订单，没有清理购物车")]),_._v(" "),t("li",[_._v("订单没创建成功，购物车里面的商品却被清掉了")])]),_._v(" "),t("p",[_._v("也就是说："),t("strong",[_._v("创建订单")]),_._v(" 和 "),t("strong",[_._v("发送消息")]),_._v(" 这两个步骤要么都操作成功，要么都操作失败，不允许一个成功而另一个失败的情况出现。"),t("strong",[_._v("这也就是事务消息解决的事情：保证生产者本地事务和发送消息的数据一致性")])]),_._v(" "),t("h2",{attrs:{id:"消息队列是如何实现事务的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#消息队列是如何实现事务的"}},[_._v("#")]),_._v(" 消息队列是如何实现事务的？")]),_._v(" "),t("p",[_._v("事务消息需要消息队列提供相应的功能才能实现，Kafka 和 RocketMQ 都提供了事务相关功能")]),_._v(" "),t("h3",{attrs:{id:"半消息"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#半消息"}},[_._v("#")]),_._v(" 半消息")]),_._v(" "),t("p",[_._v("暂时不能被 "),t("code",[_._v("Consumer")]),_._v("消费的消息。"),t("code",[_._v("Producer")]),_._v("已经把消息发送到 "),t("code",[_._v("Broker")]),_._v("端，但是此时消息并不能被消费，处于这种状态下的消息称为半消息。事实上，该状态下的消息会被放在一个叫做 "),t("code",[_._v("RMQ_SYS_TRANS_HALF_TOPIC")]),_._v("的主题下")]),_._v(" "),t("p",[_._v("当 "),t("code",[_._v("Producer")]),_._v("端对它二次确认后，也就是 "),t("code",[_._v("Commit")]),_._v("之后，"),t("code",[_._v("Consumer")]),_._v("端才可以消费到；那么如果是"),t("code",[_._v("Rollback")]),_._v("，该消息则会被删除，永远不会被消费到")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://ddmcc-1255635056.file.myqcloud.com/6c45048a-3a3b-412f-a5f3-9dd89cda37ed.png",alt:"markdown"}})]),_._v(" "),t("p",[_._v("首先，订单服务给消息服务器发送一个 "),t("code",[_._v("半消息")]),_._v("，如果 "),t("code",[_._v("半消息")]),_._v(" 发送成功，订单服务执行创建订单操作，并提交本地事务，根据本地事务结果来决定提交或回滚半消息。如果订单创建成功，那就提交半消息，购物车服务就可以消费到这条消息，如果回滚，就删除该消息，购物车服务就不会收到这条信息。这样就实现了本地事务和发送消息的一致性")]),_._v(" "),t("p",[_._v("但上面还有一个问题没有解决，如果在第 "),t("strong",[_._v("4")]),_._v(" 步提交消息时失败了怎么办？对于这个问题，"),t("code",[_._v("Kafka")]),_._v(" 和 "),t("code",[_._v("RocketMQ")]),_._v(" 给出了 2 种不同的解决方案")]),_._v(" "),t("ul",[t("li",[t("code",[_._v("Kafka")]),_._v(" 的解决方案比较简单粗暴，直接抛出异常，让用户自行处理。我们可以在业务代码中反复重试提交，直到提交成功，或者删除之前创建的订单进行补偿")]),_._v(" "),t("li",[_._v("RocketMQ 则给出了另外一种解决方案："),t("strong",[_._v("事务反查机制")])])]),_._v(" "),t("h2",{attrs:{id:"rocketmq-中的分布式事务实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rocketmq-中的分布式事务实现"}},[_._v("#")]),_._v(" RocketMQ 中的分布式事务实现")]),_._v(" "),t("h3",{attrs:{id:"事务反查机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#事务反查机制"}},[_._v("#")]),_._v(" 事务反查机制")]),_._v(" "),t("p",[_._v("如果生产者也就是订单服务，在提交或回滚事务消息时发生网络异常，导致消息队列没有收到请求，那么消息队列会定期反查这个消息对应的本地事务状态，然后根据反查结果决定提交或者回滚这个消息")]),_._v(" "),t("p",[_._v("所以订单服务需要实现一个反查本地事务状态的接口，告知消息队列本地事务是成功还是失败，"),t("code",[_._v("RocketMQ")]),_._v(" 会自动根据反查的结果提交或者回滚事务消息，消息队列会以 "),t("strong",[_._v("1")]),_._v(" 分钟的间隔时间不断回查，直至达到事务回查最大检测数（默认 "),t("strong",[_._v("15")]),_._v("），如果超过这个数字还未查询到事务状态，则回滚此消息（事务回查的频率和最大次数都可以配置）")]),_._v(" "),t("p",[_._v("使用 "),t("code",[_._v("RocketMQ")]),_._v(" 事务消息功能实现分布式事务的流程如下图")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://ddmcc-1255635056.file.myqcloud.com/0e802bc0-f315-4ab9-b380-854ed5baf7c0.png",alt:"markdown"}})]),_._v(" "),t("h3",{attrs:{id:"rocketmq-事务消息流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rocketmq-事务消息流程"}},[_._v("#")]),_._v(" RocketMQ 事务消息流程")]),_._v(" "),t("p",[_._v("发送事务消息需要实现两个方法 "),t("code",[_._v("executeLocalTransaction")]),_._v(" 和 "),t("code",[_._v("checkLocalTransaction")]),_._v(" ，一个是执行本地事务，另一个是本地事务回查")]),_._v(" "),t("p",[_._v("当调用发送消息方法时，会根据事务消息的发送结果决定是否执行本地事务方法， "),t("strong",[_._v("如果发送成功则同步调用本地事务方法 "),t("code",[_._v("executeLocalTransaction")]),_._v(" "),t("strong",[_._v("，本地事务方法返回 "),t("strong",[_._v("COMMIT")]),_._v(" 或 "),t("strong",[_._v("ROLLBACK")]),_._v(" 那么不会执行事务反查，如果")]),_._v("本地事务执行状态返回 UNKNOW 或 执行异常")]),_._v(" （本地事务状态默认为UNKNOW，且方法异常会被catch，即执行异常状态为UNKNOW，会执行反查），则定时调用 "),t("code",[_._v("checkLocalTransaction")]),_._v(" 进行事务反查")]),_._v(" "),t("h3",{attrs:{id:"步骤异常情况分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#步骤异常情况分析"}},[_._v("#")]),_._v(" 步骤异常情况分析")]),_._v(" "),t("ul",[t("li",[_._v("调用 "),t("strong",[_._v("步骤1")]),_._v(" 发送事务消息，如果 "),t("strong",[_._v("事务消息发送失败")]),_._v("，导致报错，则将异常返回，此时不会继续执行下面步骤")]),_._v(" "),t("li",[_._v("如果事务消息发送成功，但在 "),t("strong",[_._v("执行本地事务时发生异常")]),_._v(" ，那么本地事务数据不会被保存，此时 "),t("code",[_._v("Broker")]),_._v(" 会收到未知状态，  当 "),t("code",[_._v("Broker")]),_._v(" 定时回查事务状态，此时查不到本地数据，事务消息回滚")]),_._v(" "),t("li",[_._v("如果执行完本地事务，但 "),t("strong",[_._v("未能及时的返回本地事务状态或者返回了未知状态")]),_._v(" 。那么，会由"),t("code",[_._v("Broker")]),_._v("定时回查事务状态，然后根据事务日志表，就可以判断订单是否已完成，并写入到数据库。")])]),_._v(" "),t("p",[_._v("基于这些，我们可以说，已经保证了本地事务和发送消息的一致性")]),_._v(" "),t("p",[t("a",{attrs:{href:"https://github.com/ddmcc/rocketmq-demo/tree/main/transaction-message",target:"_blank",rel:"noopener noreferrer"}},[_._v("RocketMQ事务消息代码"),t("OutboundLink")],1)])])}),[],!1,null,null,null);v.default=o.exports}}]);